# Homework 5: Building a blocking deque
### Due April 11th 2024

For this programming project, you get to work in self-organized groups of up to three students if you like, but you can also do the project individually. You are not allowed to share your code, and you are not allowed to submit code generated by AI.

## The Project
This project is a variant of the previous double-ended queue (deque) programming assignment but involves blocking operations. The deque should have a maximum number of elements. Trying to add elements to a full deque should wait until the deque is no longer full. This project also add new (blocking) operations to peek at the elements on both sides of the deque.

## Specification.
Start with a specification, which must have the following methods:
- Bdeque(n): returns the initial value of an empty bdeque with at most n elements.
- put_left(d, v): d points to a bdeque and v is some value. Put v at the left-end of the bdeque. Does not return a value. Should block if the bdeque is full.
- put_right(d, v): d points to a bdeque and v is some value. Put v at the right-end of the bdeque. Does not return a value. Should block if the bdeque is full.
- get_left(d): d points to a bdeque. If the bdeque is empty, the operation should wait. Otherwise it should remove and return the value at the left-end of the bdeque.
- get_right(d): d points to a bdeque. If the bdeque is empty, the operation should wait. Otherwise it should remove and return the value at the right-end of the bdeque.
- peek_left(d): d points to a bdeque. If the bdeque is empty, the operation should wait. Oth- erwise it should return the value at the left-end of the bdeque.
- peek_right(d): d points to a bdeque. If the bdeque is empty, the operation should wait. Otherwise it should return the value at the right-end of the bdeque.

Place the entire specification in file bdeque.hny. Note that all operations except for Bdeque(n) should be atomic. Please make sure the operations are named exactly as above, or the autograder will not be able to find them.

## Implementation.
The bdeque implementation, which you should put in file bdeque impl.hny, should define the same methods but cannot use the atomically or sequential keywords and should instead rely on Lock, acquire, release, Condition, wait, notify, and notifyAll from the synch module (which the bdeque impl.hny file should import).

The implementation should not use a linked list, and should not import the malloc module. Instead, the elements of the deque should be a fixed size array, and you should keep track of the left and right indexes into this array. If the size of the array is n (which is the argument to Bdeque), the elements of the array can be initialized as [None,] * n .

You should use a lock and condition variables for the implementation. Ideally, no threads should be notified (woken up) unless they can complete the operation. So while it is possible to implement this assignment with a single condition variable, it would be better to use a condition variable per specific waiting condition.

## Testing.
You also should create a test program, in file bdeque_test.hny, for your bdeque. Note that the test should be a black box test—it cannot look inside the implementation of the bdeque. We should be able to run your test program with somebody else’s implementation of the bdeque. So, you should not deference the bdeque pointer to see what’s in it—you can only use the bdeque interface in your test program.

Testing should be based on comparing behaviors between the specification and the implemen- tation (a form of differential testing). Model your test program after the queue_btest1.hny test program from the Harmony book. It should import bdeque, not bdeque_impl.hny It should allocate a single bdeque using Bdeque(SIZE). The program should define the following constants. in the program:

- SIZE = 2: the size of the bounded buffer.
- N_PUT_RIGHT = 2: the number of threads that execute a put right operation.
- N_PUT_LEFT = 1: the number of threads that execute a put left operation.
- N_GET_LEFT = 1: the number of threads that execute a get left operation.
- N_GET_RIGHT = 1: the number of threads that execute a get right operation.
- N_PEEK_LEFT = 0: the number of threads that execute a peek left operation.
- N_PEEK_RIGHT = 1: the number of threads that execute a peek right operation.

(If there are peek operations, you’ll want to total number of put operations to exceed the total number of get operations so the peek operations do not get stuck.) For example, the program should spawn N GET LEFT threads, uniquely identified through a parameter self, each of which executes get left(d) on the bdeque d. Before the operation, the thread should print its intention to execute the operation. After the operation, the thread should print that the operation has finished and what the return value was (not needed for the put operations). We recommend that put left threads put the tuple (self, "left") on the queue, while put right threads put the tuple (self, "right") on the queue (instead of just self ).

Use the harmony flags -o bdeque.hfa and -B bdeque.hfa to compare the behaviors of the bdeque specification and the implementation. That is, you might run, for example:
    `harmony -c N_PUT_LEFT=1 -c N_PUT_RIGHT=2 -o bdeque.hfa deque_test.hny`
    `harmony -c N_PUT_LEFT=1 -c N_PUT_RIGHT=2 -B bdeque.hfa -m bdeque=deque_impl deque_test.hny`
    
You can try different numbers of threads of each type, but beware that model checkers suffer from state explosion, and thus going much beyond 6 threads total may not be feasible. (You can also, if you like, pre-populate your test bdeque before starting the threads.)

## Submitting your work
You have to submit bdeque.hny, bdeque impl.hny, and bdeque test.hny to CMSX. If you work in a group, submit your work as a single group in CMSX.
